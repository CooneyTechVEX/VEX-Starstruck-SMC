#pragma config(Sensor, in1,    dumpPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightBumper,    sensorTouch)
#pragma config(Sensor, dgtl2,  leftBumper,     sensorTouch)
#pragma config(Sensor, dgtl3,  rightQuad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftQuad,       sensorQuadEncoder)
#pragma config(Motor,  port1,           leftIntake,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           outerRightDumper, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           innerRightDumper, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           innerLeftDumper, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           outerLeftDumper, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftDrive1,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           leftDrive2,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           rightDrive1,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightDrive2,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rightIntake,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//int autoDump1 = 0;
//int autoDump2 = 0;
//int autoDump3 = 0;
//int autoDump4 = 0;
int autoDumpAll = 0;

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
/* Drive Functions */

void drive(int speed)
{
	motor[leftDrive1] = speed;
	motor[leftDrive2] = speed;

	motor[rightDrive1] = speed;
	motor[rightDrive2] = speed;
}

void driveDistance(char* type, int speed, int duration)
{
	if (type == "time")
	{
		drive(speed);
		wait1Msec(duration);
		drive((-speed * .12));
		wait1Msec(250);
		drive(0);
	}
}

void pointTurn(char* direction, int speed)
{
	if (direction == "left")
	{
		motor[leftDrive1] = -speed;
		motor[leftDrive2] = -speed;

		motor[rightDrive1] = speed;
		motor[rightDrive2] = speed;
	}
	else if (direction == "right")
	{
		motor[leftDrive1] = speed;
		motor[leftDrive2] = speed;

		motor[rightDrive1] = -speed;
		motor[rightDrive2] = -speed;
	}
	else
	{
		//Illegal Condition
	}
}

void swingTurn(char* direction, int speed)
{
	if (direction == "left")
	{
		motor[leftDrive1] = 0;
		motor[leftDrive2] = 0;

		motor[rightDrive1] = speed;
		motor[rightDrive2] = speed;
	}
	else if (direction == "right")
	{
		motor[leftDrive1] = speed;
		motor[leftDrive2] = speed;

		motor[rightDrive1] = 0;
		motor[rightDrive2] = 0;
	}
	else
	{
		//Illegal Condition
	}
}

void lift(int speed)
{
	motor[outerLeftDumper] = speed;
	motor[innerLeftDumper] = speed;

	motor[outerRightDumper] = speed;
	motor[innerRightDumper] = speed;
}

void claw(int speed)
{
	motor[leftIntake] = speed;
	motor[rightIntake] = speed;
}

bool leftStop = false;
bool rightStop = false;

void setClaw (int position, int speed)
{
	leftStop = false;
	rightStop = false;
	while (leftStop == false && rightStop == false) //Left Quad opens positive, right quad opens negative
	{
		if (SensorValue[leftQuad] < position)//Open
		{
			motor[leftIntake] = -speed;
		}
		else if (SensorValue[leftQuad] > position)//Close
		{
			motor[leftIntake] = speed;
		}
		else
		{
			motor[leftIntake] = 0;
			leftStop = true;
		}

		if (SensorValue[rightQuad] > position)//Open
		{
			motor[rightIntake] = -speed;
		}
		else if (SensorValue[rightQuad] < position)//Shut
		{
			motor[rightIntake] = speed;
		}
		else
		{
			motor[rightIntake] = 0;
			rightStop = true;
		}
	}
}

void openGrab()
{
	setClaw(250,63);
}

void closeGrab()
{
	clearTimer(T1);
	while (SensorValue[leftQuad] > 0 && SensorValue[rightQuad] > 0 && time1[T1] < 2000)
	{
		claw(-127);
	}
	claw(0);
}

void dumpAuton()
{
	lift(127);
	waitUntil(SensorValue[dumpPot] < 1400);
	claw(-127);
	waitUntil(SensorValue[dumpPot] < 1100);
	lift(-40);
	wait1Msec(500);
	claw(0);
	lift(-127);
	waitUntil(SensorValue[leftBumper] == 1 || SensorValue[rightBumper] == 1);
	lift(0);
}


/* Autonomous Selection Program using LCD for usercontrol(), in case robot resets connection and runs through pre_auton again */
const int LCD_TIMEOUT = 20000;
int selectedAutonomous = 2;
bool chooseAutonomous = false;

void autoSelection()
{
	clearTimer(T2);  //Use Timer2 to put a time limit on autonomous selection
	clearLCDLine(0);
	clearLCDLine(1);

	while (time1[T2] < LCD_TIMEOUT && chooseAutonomous == false)  //Timeout when no autonomous is selected within 20 seconds
	{

		if (nLCDButtons == 1) //Left button pressed, decrement the selected autonomous value by one
		{
			selectedAutonomous = selectedAutonomous - 1;
			wait1Msec(350);
			clearLCDLine(0);
			clearLCDLine(1);
		}
		else if (nLCDButtons == 4) //Right button pressed, increment the selected autonomous value by one
		{
			selectedAutonomous = selectedAutonomous + 1;
			wait1Msec(350);
			clearLCDLine(0);
			clearLCDLine(1);
		}
		else if (nLCDButtons == 2) //Middle button pressed, finalize selection and close autoSelection();
		{
			chooseAutonomous = true;
		}


		if (selectedAutonomous <= 1) //Could replace with a switch() statement and use cases...
		{
			selectedAutonomous = 1;
			displayLCDString(0,0,"Cube - Right");
			displayLCDString(1,0,"     Select    >");
		}
		else if (selectedAutonomous == 2)
		{
			displayLCDString(0,0,"Cube - Left");
			displayLCDString(1,0,"<    Select    >");
		}
		else if (selectedAutonomous == 3)
		{
			displayLCDString(0,0,"Empty (3)");
			displayLCDString(1,0,"<    Select    >");
		}
		else if (selectedAutonomous == 4)
		{
			displayLCDString(0,0,"Empty (4)");
			displayLCDString(1,0,"<    Select    >");
		}
		else if (selectedAutonomous == 5)
		{
			displayLCDString(0,0,"     Empty      ");
			displayLCDString(1,0,"<    Select    >");
		}
		else if (selectedAutonomous == 6)
		{
			displayLCDString(0,0,"     Empty      ");
			displayLCDString(1,0,"<    Select    >");
		}
		else if (selectedAutonomous == 7)
		{
			displayLCDString(0,0,"     Empty      ");
			displayLCDString(1,0,"<    Select    >");
		}
		else if (selectedAutonomous >= 8)
		{
			selectedAutonomous = 8;
			displayLCDString(0,0,"     Empty      ");
			displayLCDString(1,0,"<    Select     ");
		}
	}
}

/* LCD display during User Control */
int leftButtonLatch = 0;
int middleButtonLatch = 0;
int rightButtonLatch = 0;
int outsideButtonLatch = 0;
int lcdScreen = 1;
char str[32];

task matchDisplay()
{
	while (1 == 1)
	{
		// ----- LCD Buttons Watcher ----- //
		// Left Button = Launcher Readings //
		// Middle Button = Battery Levels  //
		// Right Button = Autonomous Mode  //
		// Outside Buttons = Gyro Readings //


		if (nLCDButtons == 1 && leftButtonLatch == 0)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			leftButtonLatch = 1;
			middleButtonLatch = 0;
			rightButtonLatch = 0;
			outsideButtonLatch = 0;
			lcdScreen = 2;
			wait1Msec(300);
		}
		else if (nLCDButtons == 1 && leftButtonLatch == 1)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			leftButtonLatch = 0;
			middleButtonLatch = 0;
			rightButtonLatch = 0;
			outsideButtonLatch = 0;
			lcdScreen = 1;
			wait1Msec(300);
		}

		if (nLCDButtons == 2 && middleButtonLatch == 0)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			middleButtonLatch = 1;
			leftButtonLatch = 0;
			rightButtonLatch = 0;
			outsideButtonLatch = 0;
			lcdScreen = 3;
			wait1Msec(300);
		}
		else if (nLCDButtons == 2 && middleButtonLatch == 1)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			middleButtonLatch = 0;
			leftButtonLatch = 0;
			rightButtonLatch = 0;
			outsideButtonLatch = 0;
			lcdScreen = 1;
			wait1Msec(300);
		}

		if (nLCDButtons == 4 && rightButtonLatch == 0)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			rightButtonLatch = 1;
			middleButtonLatch = 0;
			leftButtonLatch = 0;
			outsideButtonLatch = 0;
			lcdScreen = 4;
			wait1Msec(300);
		}
		else if (nLCDButtons == 4 && rightButtonLatch == 1)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			rightButtonLatch = 0;
			middleButtonLatch = 0;
			leftButtonLatch = 0;
			outsideButtonLatch = 0;
			lcdScreen = 1;
			wait1Msec(300);
		}
		else if (nLCDButtons == 3 && outsideButtonLatch == 0)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			rightButtonLatch = 0;
			middleButtonLatch = 0;
			leftButtonLatch = 0;
			outsideButtonLatch = 1;
			lcdScreen = 5;
			wait1Msec(300);
		}
		else if (nLCDButtons == 3 && outsideButtonLatch == 1)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			rightButtonLatch = 0;
			middleButtonLatch = 0;
			leftButtonLatch = 0;
			outsideButtonLatch = 0;
			lcdScreen = 1;
			wait1Msec(300);
		}


		switch (lcdScreen)
		{

		case 1:
			displayLCDCenteredString(0, "Team 9807b");
			displayLCDCenteredString(1, "VEX Starstruck");
			break;


		case 2:
			displayLCDString(0,0,"Current Auton:  ");
			sprintf(str, "CurrentAuton: %1.0f", selectedAutonomous);
			displayLCDString(1,0,str);
			//Set Auton Description
			break;


		case 3:
			sprintf(str, "Gyro: %4.1f", );
			displayLCDString(0,0,str);
			sprintf(str, "AccelX: %3.0f",);
			displayLCDString(1,0,str);
			break;


		case 4:
			sprintf(str, "Left: %8.0f", /*SensorValue[leftQuad]*/);
			displayLCDString(0,0,str);
			sprintf(str, "Right: %8.0f", /*SensorValue[rightQuad]*/);
			displayLCDString(1,0,str);
			break;


		case 5:
			displayLCDString(0,0,"||  Screen 5  ||");
			displayLCDString(1,0,"||   Select   ||");
			break;


		default:
			displayLCDCenteredString(0, "Team 9807b");
			displayLCDCenteredString(1, "VEX Starstruck");
		}
		wait1Msec(25);
	}
}

/* ======================================================================= */

void pre_auton()
{
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;

	if (nLCDButtons == 5)
	{
		autoSelection();
	}
}

task autonomous()
{
	switch (selectedAutonomous)
	{
	case 1:
		lift(-15);
		claw(-127);
		wait1Msec(150);
		claw(0);
		claw(127);
		wait1Msec(100);
		claw(0);
		wait1Msec(500);
		claw(-127);
		wait1Msec(200);
		claw(0);
		wait1Msec(500);
		drive(127);
		wait1Msec(750);
		drive(0);
		claw(127);
		wait1Msec(750);
		claw(63);
		lift(127);
		wait1Msec(300);
		lift(0);
		drive(-127);
		wait1Msec(150);
		drive(0);
		wait1Msec(500);
		pointTurn("left", 127);
		wait1Msec(400);
		lift(127);
		wait1Msec(100);
		drive(0);
		wait1Msec(750);
		driveDistance("time", -127, 1000);
		lift(127);
		waitUntil(SensorValue[dumpPot] < 1400);
		claw(-127);
		waitUntil(SensorValue[dumpPot] < 1100);
		lift(-40);
		wait1Msec(500);
		claw(0);
		lift(-127);
		waitUntil(SensorValue[leftBumper] == 1 || SensorValue[rightBumper] == 1);
		lift(-15);
		wait1Msec(250);
		driveDistance("time", 127, 900);
		wait1Msec(500);
		driveDistance("time", -127, 250);
		claw(127);
		wait1Msec(750);
		claw(25);
		driveDistance("time", -127, 900);
		dumpAuton();
		claw(0);
		//driveDistance("time", 127, 1000);
		//closeGrab();
		//pointTurn("left", 127);
		//wait1Msec(750);
		//drive(0);
		//driveDistance("time", -127, 500);
		break;

	case 2:
		lift(-15);
		claw(-127);
		wait1Msec(150);
		claw(0);
		claw(127);
		wait1Msec(100);
		claw(0);
		wait1Msec(500);
		claw(-127);
		wait1Msec(200);
		claw(0);
		wait1Msec(500);
		drive(127);
		wait1Msec(750);
		drive(0);
		claw(127);
		wait1Msec(750);
		claw(63);
		lift(127);
		wait1Msec(300);
		lift(0);
		drive(-127);
		wait1Msec(150);
		drive(0);
		wait1Msec(500);
		pointTurn("right", 127);
		wait1Msec(600);
		lift(127);
		wait1Msec(100);
		drive(0);
		wait1Msec(750);
		driveDistance("time", -127, 1000);
		lift(127);
		waitUntil(SensorValue[dumpPot] < 1400);
		claw(-127);
		waitUntil(SensorValue[dumpPot] < 1100);
		lift(-40);
		wait1Msec(500);
		claw(0);
		lift(-127);
		waitUntil(SensorValue[leftBumper] == 1 || SensorValue[rightBumper] == 1);
		lift(0);
		break;

	case 3:
		break;

	case 4:
		break;

	case 5:
		break;

	case 6:
		break;

	case 7:
		break;

	case 8:
		driveDistance("time", -127, 500);
		claw(-127);
		wait1Msec(250);
		claw(0);
		wait1Msec(500);
		driveDistance("time", 127, 450);
		claw(127);
		wait1Msec(750);
		claw(20);
		driveDistance("time", -127, 1000);
		dumpAuton();
		claw(-127);
		wait1Msec(100);
		claw(0);
		driveDistance("time", 127, 900);

		driveDistance("time", -127, 100);
		claw(127);
		wait1Msec(750);
		claw(20);
		driveDistance("time", -127, 1000);
		dumpAuton();
		claw(-127);
		wait1Msec(100);
		claw(0);
		driveDistance("time", 127, 900);

		driveDistance("time", -127, 100);
		claw(127);
		wait1Msec(750);
		claw(20);
		driveDistance("time", -127, 1000);
		dumpAuton();
		claw(-127);
		wait1Msec(100);
		claw(0);
		driveDistance("time", 127, 1000);

		driveDistance("time", -127, 100);
		claw(127);
		wait1Msec(750);
		claw(20);
		driveDistance("time", -127, 1000);
		dumpAuton();
		claw(-127);
		wait1Msec(100);
		claw(0);
		lift(-20);
		pointTurn("left", 127);
		wait1Msec(150);
		drive(0);
		wait1Msec(500);
		driveDistance("time", 127, 1000);
		wait1Msec(100);
		claw(127);
		wait1Msec(750);
		claw(0);
		wait1Msec(500);
		pointTurn("right", 127);
		wait1Msec(150);
		drive(0);
		wait1Msec(500);
		driveDistance("time", -127, 600);
		dumpAuton();

		break;
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	startTask(matchDisplay);

	while (true)
	{
		motor[leftDrive1] = vexRT[Ch3];
		motor[leftDrive2] = vexRT[Ch3];
		motor[rightDrive1] = vexRT[Ch2];
		motor[rightDrive2] = vexRT[Ch2];


		//==========================================================================================================================================//


		if(vexRT[Btn6UXmtr2] == 1 && vexRT[Btn6DXmtr2] == 0)
		{
			motor[leftIntake] = -127;
			motor[rightIntake] = -127;
		}
		else if(vexRT[Btn6UXmtr2] == 0 && vexRT[Btn6DXmtr2] == 1)
		{
			motor[leftIntake] = 127;
			motor[rightIntake] = 127;
		}
		else
		{
			motor[leftIntake] = 0;
			motor[rightIntake] = 0;
		}


		//==========================================================================================================================================//


		if(vexRT[Btn5UXmtr2] == 1 && vexRT[Btn5DXmtr2] == 0 && autoDumpAll == 0)
		{
			if(SensorValue[dumpPot] < 1100)
			{
				clearTimer(T1);
				while(time1[T1] < 500)
				{
					motor[outerLeftDumper] = ((SensorValue[dumpPot] - 1100)/10);
					motor[innerLeftDumper] = ((SensorValue[dumpPot] - 1100)/10);
					motor[innerRightDumper] = ((SensorValue[dumpPot] - 1100)/10);
					motor[outerRightDumper] = ((SensorValue[dumpPot] - 1100)/10);

					motor[leftIntake] = -127;
					motor[rightIntake] = -127;
				}
			}
			else
			{
				motor[outerLeftDumper] = 127;
				motor[innerLeftDumper] = 127;
				motor[innerRightDumper] = 127;
				motor[outerRightDumper] = 127;
			}
		}
		else if(vexRT[Btn5UXmtr2] == 0 && vexRT[Btn5DXmtr2] == 1 && autoDumpAll == 0)
		{
			if(SensorValue[leftBumper] == 1 || SensorValue[leftBumper] == 1)
			{
				motor[outerLeftDumper] = -7;
				motor[innerLeftDumper] = -7;
				motor[innerRightDumper] = -7;
				motor[outerRightDumper] = -7;
			}
			else
			{
				motor[outerLeftDumper] = -127;
				motor[innerLeftDumper] = -127;
				motor[innerRightDumper] = -127;
				motor[outerRightDumper] = -127;
			}
		}
		else if(autoDumpAll == 0)
		{
			if(SensorValue[leftBumper] == 1 || SensorValue[leftBumper] == 1)
			{
				motor[outerLeftDumper] = -7;
				motor[innerLeftDumper] = -7;
				motor[innerRightDumper] = -7;
				motor[outerRightDumper] = -7;
			}
			else
			{
				motor[outerLeftDumper] = 0;
				motor[innerLeftDumper] = 0;
				motor[innerRightDumper] = 0;
				motor[outerRightDumper] = 0;
			}
		}


		//==========================================================================================================================================//


		if(vexRT[Btn8DXmtr2] == 1)
		{
			autoDumpAll = 1;
		}
		if(autoDumpAll == 1)
		{
			while(SensorValue[dumpPot] >= 1100 && autoDumpAll == 1)
			{
				motor[outerLeftDumper] = 127;
				motor[innerLeftDumper] = 127;
				motor[innerRightDumper] = 127;
				motor[outerRightDumper] = 127;

				if(vexRT[Btn8UXmtr2] == 1)
				{
					autoDumpAll = 0;
				}
			}
			if(SensorValue[dumpPot] < 1100)
			{
				clearTimer(T1);
				while(time1[T1] < 750 && autoDumpAll == 1)
				{
					motor[outerLeftDumper] = ((SensorValue[dumpPot] - 1100)/10);
					motor[innerLeftDumper] = ((SensorValue[dumpPot] - 1100)/10);
					motor[innerRightDumper] = ((SensorValue[dumpPot] - 1100)/10);
					motor[outerRightDumper] = ((SensorValue[dumpPot] - 1100)/10);

					motor[leftIntake] = -127;
					motor[rightIntake] = -127;

					if(vexRT[Btn8UXmtr2] == 1)
					{
						autoDumpAll = 0;
					}
				}
			}
			while(SensorValue[leftBumper] == 0 || SensorValue[rightBumper] == 0 && autoDumpAll == 1)
			{
				motor[outerLeftDumper] = -127;
				motor[innerLeftDumper] = -127;
				motor[innerRightDumper] = -127;
				motor[outerRightDumper] = -127;

				if(vexRT[Btn8UXmtr2] == 1)
				{
					autoDumpAll = 0;
				}
			}
			autoDumpAll = 0;

			motor[outerLeftDumper] = 0;
			motor[innerLeftDumper] = 0;
			motor[innerRightDumper] = 0;
			motor[outerRightDumper] = 0;

			motor[leftIntake] = 0;
			motor[rightIntake] = 0;
		}



		//if(vexRT[Btn8DXmtr2] == 1)
		//{
		//	autoDump1 = 1;
		//	autoDumpAll = 1;
		//}
		//if(SensorValue[dumpPot] > 1100 && autoDump1 == 1)
		//{
		//	motor[innerLeftDumper] = 127;
		//	motor[outerLeftDumper] = 127;
		//	motor[innerRightDumper] = 127;
		//	motor[outerRightDumper] = 127;

		//	autoDump2 = 1;
		//}
		//else if(SensorValue[leftBumper] == 0 && SensorValue[rightBumper] == 0 && autoDump3 == 1)
		//{
		//	motor[leftIntake] = 0;
		//	motor[rightIntake] = 0;

		//	motor[innerLeftDumper] = -127;
		//	motor[outerLeftDumper] = -127;
		//	motor[innerRightDumper] = -127;
		//	motor[outerRightDumper] = -127;

		//	autoDump4 = 1;

		//}
		//else if(SensorValue[leftQuad] < 250 && autoDump2 == 1)
		//{
		//	autoDump1 = 0;

		//	motor[innerLeftDumper] = 0;
		//	motor[outerLeftDumper] = 0;
		//	motor[innerRightDumper] = 0;
		//	motor[outerRightDumper] = 0;

		//	motor[leftIntake] = 127;

		//	autoDump3 = 1;
		//}
		////if(SensorValue[rightQuad] > -250 && autoDump2 == 1)
		////{
		////	autoDump1 = 0;

		////	motor[innerLeftDumper] = 0;
		////	motor[outerLeftDumper] = 0;
		////	motor[innerRightDumper] = 0;
		////	motor[outerRightDumper] = 0;

		////	motor[rightIntake] = 127;

		////	autoDump3 = 1;
		////}
		//else if(autoDump4 == 1)
		//{
		//	autoDump1 = 0;
		//	autoDump2 = 0;
		//	autoDump3 = 0;
		//	autoDump4 = 0;
		//	autoDumpAll = 0;

		//	motor[innerLeftDumper] = 0;
		//	motor[outerLeftDumper] = 0;
		//	motor[innerRightDumper] = 0;
		//	motor[outerRightDumper] = 0;

		//	motor[leftIntake] = 0;
		//	motor[rightIntake] = 0;

		//	motor[innerLeftDumper] = 0;
		//	motor[outerLeftDumper] = 0;
		//	motor[innerRightDumper] = 0;
		//	motor[outerRightDumper] = 0;
		//}
		//if(vexRT[Btn8UXmtr2] == 1)
		//{
		//	autoDump1 = 0;
		//	autoDump2 = 0;
		//	autoDump3 = 0;
		//	autoDump4 = 0;
		//	autoDumpAll = 0;

		//	motor[innerLeftDumper] = 0;
		//	motor[outerLeftDumper] = 0;
		//	motor[innerRightDumper] = 0;
		//	motor[outerRightDumper] = 0;

		//	motor[leftIntake] = 0;
		//	motor[rightIntake] = 0;

		//	motor[innerLeftDumper] = 0;
		//	motor[outerLeftDumper] = 0;
		//	motor[innerRightDumper] = 0;
		//	motor[outerRightDumper] = 0;
		//}
	}
}
